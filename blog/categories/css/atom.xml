<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: css | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/css/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2018-12-16T10:16:31+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Generating Notifications and Personalized Emails Efficiently]]></title>
    <link href="http://artsy.github.io/blog/2014/04/24/generating-notifications-and-personalized-emails-efficiently/"/>
    <updated>2014-04-24T16:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2014/04/24/generating-notifications-and-personalized-emails-efficiently</id>
    <content type="html"><![CDATA[<p>We recently launched a new personalized email here at <a href="https://artsy.net">Artsy</a> that features content that a given user might find interesting. The goal of this post is to describe how we built a backend system that efficiently generates these e-mails for all our users. I'll talk about the first, naive implementation that had performance problems right away, and how the second implementation (currently in production) solved those issues, and whose behavior at scale is well-defined and understood. I won't go into the details of the design and layout of the mail itself and how we render the content - there are several earlier blog posts that deal with those: <a href="http://artsy.github.io/blog/2014/03/18/presenters-and-memoization-moving-logic-out-of-templates/">Presenters and Memoization</a>, <a href="http://artsy.github.io/blog/2014/03/17/ruby-helper-to-group-artworks-into-a-pinterest-style-layout-for-email/">Pinterest-style Layouts</a> and <a href="http://artsy.github.io/blog/2014/03/17/some-tips-for-email-layout-and-responsiveness/">Email Layouts and Responsiveness</a>.</p>

<p><img src="/images/2014-04-24-generating-notifications-and-personalized-emails-efficiently/percy_example.png" alt="Personalized Email Example" /></p>

<!-- more -->


<a name="Deciding.What.Content.to.Include"></a>
<h3>Deciding What Content to Include</h3>

<p>First, we had to decide what types of personalized content we wanted to feature in our mails. Users can follow artists and galleries, and so this seemed like a great place to start. We'd like to let you know about new artworks that have been uploaded by artists that you follow, as well as new shows that have been added by galleries you follow, or that are exhibiting artists you follow. Since we have location data for our galleries and our users (accomplished thru an onboarding flow, or thru geo-locating their IP address), we also want to include new shows that are opening near you. Additionally, we have a recommendations engine that recommends artworks to users based on their preferences and activity on the site, and we'd like to show some of the latest and best of such recommendations.</p>

<a name="Initial.Implementation.Ideas"></a>
<h3>Initial Implementation Ideas</h3>

<p>My first thought was to have an observer (really just some <code>after_save</code> callbacks) that will wait for data to get into a state where a user can be validly notified, and in a background task write these notifications to interested users. Here's how the base setup of our <code>Notification</code> model looked:</p>

<pre><code class="ruby">class Notification
  include Mongoid::Document
  include Mongoid::Timestamps

  belongs_to :user
  belongs_to :notifiable, polymorphic: true, inverse_of: :notifications
end
</code></pre>

<p>It's a simple join of the user and the <code>notifiable</code> (the object/action that a user is being notified about).</p>

<p>Then, a specific notification (such as one for published artworks by artists you follow) can inherit from this and look like:</p>

<pre><code class="ruby">class PublishedArtworkNotification &lt; Notification
  def self.notify!(artwork_id)
    user_ids = FollowArtist.where(artist: artwork.artist).pluck("user_id")
    user_ids.each_slice(100) do |uids|
      PublishedArtworkNotification.delay(queue: :any, priority: 6).create_for_users(artwork_id, uids)
    end
  end

  def self.create_for_users(artwork, uids)
    uids.each do |uid|
      PublishedArtworkNotification.create!(user_id: uid, notifiable_id: artwork_id, notifiable_type: 'Artwork')
    end
  end
end
</code></pre>

<p>Then, the <code>after_save</code> hook on an <code>Artwork</code> model is:</p>

<pre><code class="ruby">def delay_notify
  PublishedArtworkNotification.delay(queue: :any).notify!(self.id) if self.published_changed? &amp;&amp; self.published
end
</code></pre>

<p>So, when an artwork is published, we run <code>notify!</code> in the background for the respective notification. That method will pull all interested users (via following the artist), and then spawn off more background processes to write the notifications in batches of 100. We batched these writes to avoid any one background process taking too long (an artist such as <a href="https://artsy.net/artist/andy-warhol">Andy Warhol</a> has around twelve thousand followers currently), and also ran them at a lower priority to avoid blocking other jobs in our queue.</p>

<p>The other types of notifications were all implemented similarly (via an observer on the model, and a specific <code>Notification</code> class inheriting from the base class). We also added some other logic into the base <code>Notification</code> class such as some uniqueness constraints, as well as an ability to mark notifications as 'sent' or 'invalid'. However, we ran into serious performance/scaling issues fairly quickly, and had to re-implement this scheme.</p>

<a name="Performance.Bottlenecks"></a>
<h3>Performance Bottlenecks</h3>

<p>All of these records were being written to one collection in <a href="https://www.mongodb.org/">MongoDB</a>, and the size of this collection grew quite rapidly. It's size almost immediately dwarfed the size of any of our other collections, and the number of records quickly reached into the tens of millions. This led to problems: writing new notifications started to crawl to a standstill. We had several indices on this collection to aid in querying, and these made the insertion of new notifications very non-performant, and also started to affect overall database performance. Querying against this collection degraded quickly and started to similarly affect database performance. Archiving old records also proved next to impossible. We couldn't simply drop the entire collection, but had to prune records. This similarly was totally non-performant and was adversely affecting database and site performance. We needed to come up with a new implementation for <code>Notification</code>, and addressing these issues was essential.</p>

<a name="Resolving.Performance.Bottlenecks"></a>
<h3>Resolving Performance Bottlenecks</h3>

<p>So, we decided on a scheme where each day would result in a new <code>Notifications</code> collection (name keyed on the date), named <code>notifications_20140101</code>, <code>notifications_20140102</code>, etc. Each of these collections would have an <code>_id</code> field that corresponds to a user_id, and an <code>events</code> array (or 'stack' if you will) that records the id's of notified objects, as well as the type of notification. An example of a record in that collection is:</p>

<pre><code class="json">{"_id"=&gt;"5106b619f56337db300001f8",
 "events"=&gt;[{"t"=&gt;"NearbyShow", "o"=&gt;"533998b1c9dc24c371000041"},
            {"t"=&gt;"NearbyShow", "o"=&gt;"5345774cc9dc246d580003d0"},
            {"t"=&gt;"NearbyShow", "o"=&gt;"5335af4fa09a67145300028c"},
            {"t"=&gt;"NearbyShow", "o"=&gt;"533f1174a09a67298900007b"},
            {"t"=&gt;"ArtworkPublished", "o"=&gt;"5334647b139b2165160000d8"}]
}
</code></pre>

<p>So, here we see all of my notifications for April 22, 2014. On that day, I was notified about 4 shows opening near my location, and one artwork added by an artist I follow. Incidentally, that artwork was a piece by <a href="https://artsy.net/artist/rob-wynne">Rob Wynne</a> entitled <a href="https://artsy.net/artwork/rob-wynne-youre-dreaming">You're Dreaming</a>. The show notifications were for NYC-area shows opening at <a href="https://artsy.net/klein-sun-gallery">Klein Sun Gallery</a>, <a href="https://artsy.net/garis-and-hahn">Garis &amp; Hahn</a>, <a href="https://artsy.net/miyako-yoshinaga-gallery">Miyako Yoshinaga Gallery</a> and <a href="https://artsy.net/dodgegallery">DODGEgallery</a>.</p>

<p>A couple of nice things about this implementation is it limits the size of a collection: any one day's collection will scale directly with the number of users, which seems reasonable. Our earlier implementation scaled with the product of the number of users and amount of content on Artsy, which is clearly problematic. Also, archiving old notifications is as simple as dropping a particular day's collection, which is very performant. However, querying and assembling these notifications is a bit trickier than in the naive implementation, as well as marking which events have already been sent to a user, so as to avoid duplicating any content in between mailings.</p>

<p>Let's see how we rewrite the notification generation in this scheme:</p>

<pre><code class="ruby">module NotificationService

  def self.notify_many!(user_ids, object_id, type)
    events = events_from(object_id, type)
    user_ids.each do |user_id|
      notify_with_events(user_id, events)
    end
  end

  private

  def self.notify_with_events(user_id, events)
    collection.find(_id: user_id).upsert('$push' =&gt; { events: { '$each' =&gt; events } })
  end

  def self.events_from(object_ids, type)
    Array(object_ids).map do |object_id|
      {
        't' =&gt; type,
        'o' =&gt; object_id
      }
    end
  end

  # collection storing notifications for the given day
  def self.collection(date = Date.today)
    Mongoid.default_session.with(safe: false)[collection_name(date)]
  end

  def self.collection_name(date)
    "notifications_#{date.to_s(:number)}"
  end

end
</code></pre>

<p>Here's how the <code>after_save</code> callback looks now:</p>

<pre><code class="ruby">def notify_published
  NotificationService.notify_many!(user_ids, self, 'ArtworkPublished') if self.published_changed? &amp;&amp; self.published
end
</code></pre>

<p>Let's take a look at what's going on here. When an artwork is published, we call <code>notify_many!</code> in the <code>NotificationService</code> module. That will determine the correct collection (keyed by the date) using the <code>collection</code> and <code>collection_name</code> helpers. We build our events stack with the <code>events_from</code> helper, and then do an <code>upsert</code> with a <code>$push</code> to either insert or update that user's events for that day. Due to the fast performance of this scheme, we also no longer have to batch notification creation. As a sample benchmark, writing this type of notification to our <a href="https://artsy.net/artist/andy-warhol">Warhol</a> followers takes under 15 seconds.</p>

<p>Ok, so we seem to have solved some of our issues: namely writing and archiving notifications is performant, and we understand the behavior of these collections as the number of users and content on the site grows. Now let's look at how we can query against this scheme in an efficient manner, and also how we can mark events as 'seen' to avoid emailing out duplicates.</p>

<a name="Marking.Notifications.as.Flushed.and.Retrieving.Notifications"></a>
<h3>Marking Notifications as Flushed and Retrieving Notifications</h3>

<p>We decided to push a <code>flushed</code> event onto the user's stack after we send out notifications, and analogously, when we are querying a user's notifications, we want to throw away notifications that occur before a <code>flushed</code> event. Here's that method, in our <code>NotificationService</code> module:</p>

<pre><code class="ruby"># Mark all events until this point "seen." Pushes a {flushed: &lt;id&gt;}
# hash on to events array.
def self.flush!(user_id, since = Date.today - 7.days)
  flushed = { 'flushed' =&gt; Moped::BSON::ObjectId.new }
  collections_since(since).each do |coll|
    coll.find(_id: user_id).update('$push' =&gt; { events: flushed })
  end
  flushed  # return "id" of flushed marker, in case useful later
end

private

def self.collections_since(date)
  (date..Date.today).map { |d| collection(d) }
end
</code></pre>

<p>Pretty simple. We push the appropriate event onto every collection that was under consideration via the <code>collections_since</code> helper. When we send out a personalized email we accumulate the last 7 day's worth of activity for you, and so after we generate/send a mail for a user, we can simply say <code>NotificationService.flush!(user)</code>. Here's how that day's notifications for me looks after the <code>flushed</code> event:</p>

<pre><code class="json">  {"_id"=&gt;"5106b619f56337db300001f8",
   "events"=&gt;[{"t"=&gt;"NearbyShow", "o"=&gt;"5338504e139b21f2a9000362"},
              {"t"=&gt;"FollowedArtistShow", "o"=&gt;"533ddba3a09a6764f60006b6"}, {"t"=&gt;"NearbyShow", "o"=&gt;"533ddba3a09a6764f60006b6"},
              {"flushed"=&gt;"5352b346b504f5f3690002fe"}]
  }
</code></pre>

<p>For the last piece of the puzzle, let's look at how we query against this scheme and compile together all notifications that are applicable for a given user:</p>

<pre><code class="ruby">module NotificationService
  NOTIFICATION_TYPES = {
    'FollowedArtistShow' =&gt; PartnerShow,
    'FollowedPartnerShow' =&gt; PartnerShow,
    'NearbyShow' =&gt; PartnerShow,
    'ArtworkPublished' =&gt; Artwork,
    'ArtworkSuggested' =&gt; Artwork
  }

  class Notification &lt; Struct.new(:type, :object_id)
    def object
      @object ||= NOTIFICATION_TYPES[type].find(object_id)
    end

    def applicable?
      object.try(:notifiable?) || false
    end
  end

# Return applicable notifications for user since given date.
def self.get(user_id, since = Date.today - 7.days)
  collections_since(since)
    .map { |coll| coll.find(_id: user_id).one }.compact
    .flat_map { |doc| doc['events'].slice_before { |ev| ev['flushed'] }.to_a.last }
    .reject { |ev| ev['flushed'] }.uniq
    .map { |ev| Notification.new(ev['t'], ev['o']) }.select(&amp;:applicable?)
end
</code></pre>

<p>We introduce a lite-weight <code>Notification</code> class that will load the object, as well as perform an additional check. We use the previously introduced <code>collections_since</code> helper to retrieve all the notification collections under consideration. We query each and build up an array of all events from a user's stack. We remove events that occurred prior to a <code>flushed</code> event in a given collection and the <code>flushed</code> events themselves. Then we actually load all the objects and return the ones that are still <code>applicable?</code>. That final <code>applicable?</code> check is to allow us to filter out content at run-time that is no longer valid. For example, if an artwork is published and the correct event is written out to users, but before the user can be notified the artwork is unpublished, this can serve as a run-time check to not include that work. <code>def notifiable?</code> can thus be implemented in the <code>Artwork</code> model like so:</p>

<pre><code class="ruby">def notifiable?
  published?
end
</code></pre>

<p>And...that's basically it! Throughout the week as partners are uploading their shows/fair booths/artworks, these records are being opportunistically written to that day's notification collection, in a performant and scalable fashion. Then when we want to send you a personalized email, we pull all your appropriate notifications via the <code>get</code> routine in our <code>NotificationService</code>, and primarily using the technique described in <a href="http://artsy.github.io/blog/2014/03/18/presenters-and-memoization-moving-logic-out-of-templates/">Presenters and Memoization</a> we make sure we cache/memoize all such data. Using the tips in <a href="http://artsy.github.io/blog/2014/03/17/ruby-helper-to-group-artworks-into-a-pinterest-style-layout-for-email/">Pinterest-style Layouts</a> and <a href="http://artsy.github.io/blog/2014/03/17/some-tips-for-email-layout-and-responsiveness/">Email Layouts and Responsiveness</a> we can render this content and support various devices/email clients. We parallelize and batch the generation/sending of our e-mails as well. This whole system, from notification generation to actually emailing users, is running successfully and smoothly in production.</p>

<a name="Next.Steps"></a>
<h3>Next Steps</h3>

<p>I think this type of infrastructure can easily be adapted to serve as a feed on a front-end or other client app. An API to serve up these notifications (AKA feed items) can be built and different feed items can then be rendered or aggregated at load-time. Simple client-side polling can even be set up to alert a user if something has happened that interests them <em>while</em> they're browsing! I think push notifications and other messaging can be handled by this system as well.</p>

<p>I'd love to hear any feedback and thoughts, and hopefully you've found this post informative and interesting. Please leave any feedback in the comments and <a href="https://github.com/artsy">follow us on Github</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Helper to Group Artworks into a Pinterest-style Layout for Email]]></title>
    <link href="http://artsy.github.io/blog/2014/03/17/ruby-helper-to-group-artworks-into-a-pinterest-style-layout-for-email/"/>
    <updated>2014-03-17T19:32:00+00:00</updated>
    <id>http://artsy.github.io/blog/2014/03/17/ruby-helper-to-group-artworks-into-a-pinterest-style-layout-for-email</id>
    <content type="html"><![CDATA[<p><img src="/images/2014-03-17-ruby-helper-to-group-artworks-into-a-pinterest-style-layout-for-email/two-column-layout.png" alt="Example of two column layout" /></p>

<p>Something we'd like to do is email our users some suggested artworks as part of their personalized emails. The layout of those suggestions should look something like our newly re-designed <a href="https://artsy.net/browse/artworks?price_range=-1%3A1000000000000">Browse</a> page, with a 'salon' style layout. Here's some simple Ruby code that can group artworks into columns for you, that can then be directly rendered in an email (via <a href="http://haml.info/">Haml</a>, <a href="http://mustache.github.io/">Mustache</a>, <a href="http://jade-lang.com/">Jade</a>, or your templating language of choice.)</p>

<!-- more -->


<a name="The.code"></a>
<h2>The code</h2>

<p>First let's look at the code, and then I'll describe it:</p>

<pre><code class="ruby">module ArtworkColumns
  # Return an array of artworks grouped together in sub arrays by being added to the shortest 'column'
  # based on a fixed width and aspect ratios.
  #
  # @param {Array} artworks The array of artworks to group into columns
  # @param {Number} num_columns The number of columns to group them into
  # @param {Number} width The width the images will be displayed at
  #
  # @return {Array} An array of artworks grouped into sub arrays by being added to the shortest one.
  def self.artwork_columns(artworks, num_columns, width)
    artwork_cols = []

    # Initialize columns
    num_columns.times do
      artwork_cols &lt;&lt; []
    end

    artworks.each do |artwork|
      add_to_shortest_column!(artwork_cols, artwork, width)
    end

    artwork_cols
  end

  private

  # Adds artwork to shortest column
  def self.add_to_shortest_column!(artwork_cols, artwork, width)
    min_height = column_height(artwork_cols[0], width)
    min_column_idx = 0

    artwork_cols.each_with_index do |column, idx|
      height = column_height(column, width)
      if height &lt; min_height
        min_height = height
        min_column_idx = idx
      end
    end

    artwork_cols[min_column_idx] &lt;&lt; artwork
  end

  # Calculate sum of heights of artworks in column
  def self.column_height(artwork_col, width)
    height = 0
    artwork_col.each do |artwork|
      if (aspect_ratio = artwork.default_image.aspect_ratio)
        height += (width / aspect_ratio).floor
      else
        height += width
      end
    end
    height
  end
</code></pre>

<p>The algorithm is quite simple (original JS idea and implementation courtesy of Artsy's <a href="https://github.com/gib">Gib</a>). The inputs are fairly obvious, an array of artworks to be grouped, the number of columns to group them into, and the width of each column.</p>

<p>We then simply iterate over all our artworks, and add them to whichever column is shortest. This way we end up with several columns that are for the most part equally sized in height, and as they all have different aspect ratios, when they are rendered in a table, you wind up with a nice looking 'dynamic' layout. The height of each column is calculated as the sum of the heights of the artworks in each column. The heights are derived from the inputted widths and aspect ratios of the images.</p>

<p>Here's how you might iterate over the returned column groupings and render a layout similar to the above:</p>

<pre><code class="haml">- artwork_suggestions.each_with_index do |artwork_arr, idx|
  %td{ id: 'artwork-column', style: "width: 290px;padding-top:20px;text-align:left;" }
    - artwork_array.each do |artwork|
      %a{ href: "#{canonical_url}/artwork/#{artwork.slug}?#{@utm_params}" }&lt;
        %img{ id: 'artwork', src: "#{artwork.default_image.image_url(:large)}", style: "width: 290px;" }
      %br
      &lt;!-- additional artwork details, title, artist, etc. --&gt;
</code></pre>

<p>These few lines of Ruby code have allowed us to move logic out of Haml (yuck!) and into Ruby (yay!) and allow <a href="http://haml.info/">Haml</a> to just focus on rendering the objects passed in (certainly via loops and conditionals, etc.)</p>

<p>That's all for now! In my next post I'll talk about how I use the Presenter pattern and memoization to move even more logic out of templates (and save some database calls while we're at it!)</p>

<p>Thanks again! Post any comments or tips of your own here, and <a href="https://github.com/artsy">follow us on Github</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some Tips for Email Layout and Responsiveness]]></title>
    <link href="http://artsy.github.io/blog/2014/03/17/some-tips-for-email-layout-and-responsiveness/"/>
    <updated>2014-03-17T12:36:00+00:00</updated>
    <id>http://artsy.github.io/blog/2014/03/17/some-tips-for-email-layout-and-responsiveness</id>
    <content type="html"><![CDATA[<p><img src="/images/2014-03-17-some-tips-for-email-layout-and-responsiveness/analytics.png" alt="Example of Analytics Email" /></p>

<p>Email can be one of the most powerful ways to engage with your users, and can serve a multitude of purposes. It can be used as a way to highlight selected content (weekly/monthly newsletters, 'year in review', etc.), provide a service to users (analytics breakdown of visits to your profile/favorites page), or re-engage with users (new feature announcements, etc.). Here at Artsy we use all of these kinds of emails and have found them to be a very valuable asset. However, best practices for template layout and CSS (keeping in mind the variety of devices and screen sizes that your users have) are quite different from, and very far behind, the current HTML5 standards and practices for making beautiful web pages. In this article, I'd like to present some techniques I've successfully used at Artsy to create emails that look good on your browser or mobile device, in some of the most popular email clients out there.</p>

<!-- more -->


<a name="The.Main.Difference.Between.Email.and.Web"></a>
<h2>The Main Difference Between Email and Web</h2>

<p>A fundamental difference between email and web, and which essentially accounts for the completely different methodology and rules you should follow for emails, is that of the rendering client. In 2014, (assuming you are not supporting certain legacy versions of Internet Explorer and other old versions), browsers for the most part will render passed in HTML and CSS in a standard fashion. While there are some notable exceptions still, graceful degradation is quite possible. That is because the only 'interpreter' of your HTML is the end user's browser, which operates under a certain set of known rules. With emails however, the interpreter is the end user's mail client of choice, which can be: native iOS apps, web apps, and even standalone desktop applications. All of these do their own parsing/interpreting before rendering, which can cause HTML that results in a nice looking web page to look totally broken in an email, as well as the same exact email looking remarkably different across mail clients. One of the main reasons why email clients do this is to remove things that might interfere with the rendering of the mail client itself, or any security risks.</p>

<p>Also of note is that the use of Javascript within an email is of course, not possible. Additionally, the HTML that will be emailed to your users needs to be sent as one file with inlined CSS. You can use a tool like <a href="https://github.com/premailer/premailer/">premailer</a> to allow you to develop your CSS separately and then convert to an inline style.</p>

<a name="Some.Basics.about.Tables"></a>
<h2>Some Basics about Tables</h2>

<p>Yes, it's 2014, and yes, we're going to talk about tables on an engineering blog. That's because for emails, tables are going to be your main tool to position and lay out your content. Two of the most common CSS selectors (<code>position</code> and <code>display</code>) are bad ideas to use in email. They are mostly unsupported by mail clients (which will reach in and rewrite your HTML/CSS) and will lead to unexpected looking output. However, you can achieve virtually any layout desired using tables.</p>

<p>Here is sample HTML that generates the top part of the email shown above. While it may make your eyes bleed from the table use, notice we are able to achieve the beginnings of a basic 3-column layout, with equal-width columns and centered headers/text with no position-related CSS.</p>

<p>``` html</p>

<table border='0' cellpadding='0' cellspacing='0' style='margin: 0 20px; table-layout: fixed;' width='600px'>
  <tr>
    <td align='center' colspan='3' style='padding: 0px 0px 15px' valign='middle'>
      <font color='black' style='font-family: Georgia, serif;font-size: 16px; line-height: 1.3em; letter-spacing:2px;text-transform:uppercase;'>
        Cats Galore at the Cat Art Fair 2014
      </font>
    </td>
  </tr>
  <tr>
    <td align='left' style='padding: 0px 0px 15px; border-right: 1px solid grey;' valign='middle'>
      <font color='black' style='font-family: Georgia, serif;font-size: 16px; line-height: 1.3em;'>
        <div style='text-align: center; font-size: 23px;'>
          24
        </div>
        <div style='text-align: center;'>
          works
          in your booth
        </div>
      </font>
    </td>
    <td align='middle' style='padding: 0px 0px 15px; border-right: 1px solid grey;' valign='middle'>
      <font color='black' style='font-family: Georgia, serif;font-size: 16px; line-height: 1.3em;'>
        <div style='text-align: center; font-size: 23px;'>
          3,086
        </div>
        <div style='text-align: center;'>
          total artwork views
        </div>
      </font>
    </td>
    <td align='right' valign='middle'>
    <font color='black' style='font-family: Georgia, serif;font-size: 16px; line-height: 1.3em;'>
      <div style='text-align: center; font-size: 23px;'>
        471
      </div>
      <div style='text-align: center;'>
        cities reached
      </div>
    </font>
    </td>
  </tr>
  <!-- more content below -->
</table>


<pre><code>
Now under this we present a heatmap and table of top views by city. For that we use the same 3-column table, except specify a colspan of 2 on the column that contains the heatmap. That is because we would like that column to take up a width equal to the first 2 columns of the equally spaced three at the top, and the table of top views will take up the last column. Here's that markup:
</code></pre>

<pre><code>&lt;tr&gt;
&lt;td align='left' colspan='2' style='padding: 0px 0px 15pxl; width: 66%;' valign='middle'&gt;
  &lt;div&gt;
    &lt;img src='link_to_heatmap.png' width='400px'&gt;
  &lt;/div&gt;
&lt;/td&gt;
&lt;td align='right' style='padding: 0px 23px 15px; width: 33%; text-align:left;' valign='middle'&gt;
  &lt;font color='black' style='font-family: Georgia, serif;font-size: 12px; line-height: 1.3em; font-weight:bold;'&gt;
    Top 10 Cities
  &lt;/font&gt;
  &lt;font color='black' style='font-family: Georgia, serif;font-size: 12px; line-height: 1.3em;'&gt;
    New York
    21.66%
    &lt;br&gt;
    London
    3.34%
    &lt;br&gt;
    &lt;!-- 'br' separated string of views --&gt;
  &lt;/font&gt;
&lt;/td&gt;
</code></pre>

<p>  </tr>
```</p>

<p>Notice that again we are using no position or display related CSS. However, now our table has a 3 column section and a 2 column section, and we are well on our way to creating a nice email! I kept these as separate rows in the same table, but could have equivalently had each of them be their own table with no ill effects and almost the same markup. Depending on your design and layout, you may need to have multiple tables (nested and not) to support different widths and column layouts, however they should all just <em>work</em>.</p>

<a name="Background.Images.and.Overlayed.Text"></a>
<h2>Background Images and Overlayed Text</h2>

<p>Ok, so tables are all well and good and you can achieve a lot using them, and without having to use any display or position CSS. But what if you want to overlay text on an image? (or even another image over an image)? On a web page, there are many ways to accomplish that, but they all use CSS that you really should not be using in emails (namely: <code>position</code>, <code>display</code>, <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code>, and most layout properties besides padding. Also, no negative padding please!). But no worries, because you can still accomplish that using background images!</p>

<p>Here is an example from our current welcome mail to users:</p>

<p><img src="/images/2014-03-17-some-tips-for-email-layout-and-responsiveness/welcome_desktop.png" alt="Example of Welcome Mail" /></p>

<p>The top part (the iPhone pic) is actually two images (the picture, and the App Store logo), as well as some text overlayed on top. Here is the HTML to accomplish that:</p>

<p>``` html</p>

<table cellpadding='0' cellspacing='0' id='iphone-table' style='border: 0;padding:10px 0px 15px 0px;width:625px' width='625'>
  <tr>
    <td align='left' valign='middle'>
      <table background='link_to_phone.png' cellpadding='0' cellspacing='0' height='265' style='height:265px;width:625px' width='625'>
        <tr>
          <td style='padding-top:57px;padding-right:53px;padding-left:375px;text-align:center;'>
            <div style='line-height:26px;'>
              <font style='text-transform: uppercase; font-size: 19px; font-family: Georgia, serif; color: white;-webkit-font-smoothing:antialiased;'>
                Download Artsy for iPhone
              </font>
            </div>
            <div style='padding-top:10px;'>
              <font style='font-size: 14px; font-family: Georgia, serif; color: white;-webkit-font-smoothing:antialiased;'>
                The art world in your pocket.
              </font>
            </div>
          </td>
        </tr>
        <tr>
          <td align='right' style='padding-right:82px;vertical-align:top;'>
            <a href='https://itunes.apple.com/us/app/artsy-art-world-in-your-pocket/id703796080?ls=1&amp;mt=8'>
              <img src='app_store.png' style='border: none; outline: none; vertical-align:top;' width='140px'>
            </a>
          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>


<pre><code>
I chose to use a separate table to hold this content, where the background image for this table is the picture of the iPhone in hand. That table (with a background of the photo) has two rows, each with one column. The first row which is for the top part of the image, contains the 'Download' white text. That is positioned within the column through padding, which is well supported by most mail clients (as long as it's positive padding that is!) The second row, for the bottom part of the image, is a picture of the 'Download on the App Store' logo, and we chose to put that in an anchor tag and link to the App Store. You could have alternatively made this image a background as well to achieve the same overlay effect, as well as added more overlaid text, etc.

Essentially, to overlay text on images, and images on images - your only option in email is to use background images.

## Mobile Responsiveness

Ok, at this point we know how to craft some 'dynamic' layouts, (multi-column, sidebar, etc) and can overlay text and images for added effect. Now let's think about how this should work/look on a mobile device. Media queries will be our tool of choice here (well supported by mobile mail clients, with a notable exception being the Gmail iOS app.)

Something to keep in mind, depending on your use case, is to potentially design the email in the first place with mobile in mind. This can mean larger font sizes across the layout, as well as a single or two column layout max for your content. Since you have much less screen space to work with on mobile, the media queries we are going to use will largely be to increase font sizes, as well as using 'width' and 'float' to force a two column layout into one column (as an example). Depending on the mail design, this can be simple to do, or quite tricky. It's worth considering this in your initial designs.

Now the first thing to do is to include the following meta tag in your HTML:
</code></pre>

<p>  <meta name='viewport' content='width=device-width, initial-scale=1.0'>
```</p>

<p>This will tell the browser to treat the viewport size as the size of the device that is being used. This combined with media queries will enable us to create mobile emails.</p>

<p>As an example, consider the following two images. The first is the desktop version of the top part of a personalized weekly mail (blog post on how we efficiently generate these to come!), and the second is the mobile version of that same mail.</p>

<p><img src="/images/2014-03-17-some-tips-for-email-layout-and-responsiveness/personalized_desktop.png" alt="Example of Personalized Desktop" /></p>

<p><img src="/images/2014-03-17-some-tips-for-email-layout-and-responsiveness/personalized_summary.png" alt="Example of Personalized Mobile" /></p>

<p>The markup for this is pretty vanilla (similar to above, 3 column layout in a table). For mobile, we want to left-align everything and trim things down to one column. Of note here is that we are truncating text with ellipsis in the desktop version, and when the content reflows to one column we actually have <em>more</em> room to reveal the text (but still keeping truncation in just in case), so we have to enclose the text in a <code>div</code> (must have a block element for truncation)</p>

<p>Here is how we truncate text:</p>

<pre><code class="html">  &lt;div id='row-to-expand' style='white-space:nowrap;overflow:hidden;text-overflow:ellipsis;width:150px;'&gt;
    Some really long text that will get truncated
  &lt;/div&gt;
</code></pre>

<p>We specify a width on a block-level element and then use the ellipsis trick. Here's another screenshot of the truncation in action:</p>

<p><img src="/images/2014-03-17-some-tips-for-email-layout-and-responsiveness/personalized_shows.png" alt="Example of Shows Listing" /></p>

<p> Our first media query can be something like:</p>

<pre><code class="css">  @media (max-device-width: 320px){
    div[id='row-to-expand']{
      width: 260px !important;
    }
  }
</code></pre>

<p>We've set the breakpoint at 320px (vertical layout on an iPhone), and at widths less than or equal to that, this rule will kick in. Note the '!important' at the end (all of our media queries will have that to allow them to override the existing inline CSS). This is enough to expand that div and reveal more text.</p>

<p>Here's the media queries for the rest of this section that transforms the three column layout into one:</p>

<pre><code class="css">  @media (max-device-width: 320px){
    td[id='summary-col']{
      float: left !important;
    }
    td[id='summary-header']{
      float: right !important;
      width: 300px !important;
    }
    td[id='nested-summary-col']{
      width: 300px !important;
      float: left !important;
      padding: 0px !important;
    }
    table[id='summary']{
      width: 300px !important;
    }
  }
</code></pre>

<p>where the <code>td[id='nested-summary-col']</code> are the <code>td</code>s that hold the thumbnail and artist or gallery name.
Essentially all we are doing is changing the width of the container/parent table to 300px, and then making the width of each <code>td</code> 300px and adding a float. This will force your table to now be a one column layout- easy!</p>

<a name="Some.misc..email.tweaks"></a>
<h3>Some misc. email tweaks</h3>

<p>Sometimes it becomes necessary to hide/show certain things for mobile or desktop. This can be a bit tricky due to not being able to use <code>display:none;</code> , so here are a few things I've found that worked:</p>

<ul>
<li><code>width: 0px;</code> (works for hiding images)</li>
<li><code>line-height: 0px;</code> (works for hiding text)</li>
<li><code>font-size: 0px;</code> (works for hiding text)</li>
</ul>


<p>Another thing you might encounter is that text links automatically become blue in email. This is because many mail clients will take an un-styled or black link text and make them a default blue color. An easy hack to get around this is to explicitly color your links something like '#000001'. This 'almost-black' will be left untouched by mail clients, yet is close enough to black that the naked eye can't perceive the difference.</p>

<p>Here's a screenshot of an <a href="https://github.com/desandro/isotope">isotope</a> or <a href="https://www.pinterest.com/">Pinterest</a> column style layout, with truncation of text, and resized for mobile (running the full gamut of tricks):</p>

<p><img src="/images/2014-03-17-some-tips-for-email-layout-and-responsiveness/personalized_suggestions.png" alt="Example of Personalized Suggestions" /></p>

<p><a href="https://gist.github.com/mzikherman/9610125">Here is a gist</a> I use to prepare artworks for a columnar display like this. You pass in a collection of artworks (where each artwork is arbitrarily sized), and the number of columns and width of the desired output. It will return the artworks grouped into columns that can be directly rendered in an email, while respecting aspect ratios and ensuring the columns are of <em>approximately</em> equal height - resulting in a dynamic feeling layout. For this email, we group this set of artworks into 2 coumns, with each column having a width of 300px (for desktop).</p>

<a name="Great.tools.to.use:"></a>
<h2>Great tools to use:</h2>

<ul>
<li><a href="https://github.com/premailer/premailer/">Premailer</a> This will enable you to develop CSS in a sane (ie- not inline) way, and then at generation/compile time, inline it for you.</li>
<li><a href="http://litmus.com/">Litmus</a> Using Litmus's VM's with different OS's and mail clients, you can preview how a sample email will look among all sorts of different configurations. I recommend figuring out what mail clients/browsers/OS's you want to target and making sure you test all your emails here.</li>
<li><a href="http://haml.info/">Haml</a> (or any templating language of choice). A lot of the blocks of content in our mails are dynamically generated, and Haml's conditionals and looping syntax, as well as
Ruby-style string evaluation has proven invaluable.</li>
</ul>


<hr />

<p>That's all for now! With a lot of trial and error, I've built up a toolbelt of tricks, techniques and hacks I've been using to develop responsive and pretty emails quickly. I think of the limited set of tools at my disposal as a puzzle with which you can still create great looking and responsive layouts to feature your content. Previewing mails using <a href="http://mailchimp.com/features/inbox-inspector/">Inbox Inspector</a> have enabled me to craft, deploy, and send them to our users with confidence. Post any comments or tips of your own here, and <a href="https://github.com/artsy">follow us on Github</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS Trick: Adjusting Text Underlines]]></title>
    <link href="http://artsy.github.io/blog/2012/04/10/css-trick-adjusting-text-underlines/"/>
    <updated>2012-04-10T16:32:00+00:00</updated>
    <id>http://artsy.github.io/blog/2012/04/10/css-trick-adjusting-text-underlines</id>
    <content type="html"><![CDATA[<p>Often times people will use <em>border-bottom: 1px solid</em> in favor of <em>text-decoration: underline</em> to give their links some breathing room. But what if you're giving it <em>too</em> much breathing room and want to adjust the height of that underline. With Adobe Garamond that happened to be the case, so we've come up with this little css trick:</p>

<pre><code class="css">a {
  display: inline-block;
  position: relative;
}
a::after {
  content: '';
  position: absolute;
  left: 0;
  display: inline-block;
  height: 1em;
  width: 100%;
  border-bottom: 1px solid;
  margin-top: 5px;
}
</code></pre>

<p>This overlays a CSS pseudo element with a border-bottom that can be adjusted by changing margin-top.</p>

<p>For handling browsers that don't support pseudo elements I recommend targeting them with the <a href="http://paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/">Paul Irish class-on-html-trick</a>.</p>

<p>Let your links breathe!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Responsive Layouts with CSS3]]></title>
    <link href="http://artsy.github.io/blog/2012/01/17/responsive-layouts-with-css3/"/>
    <updated>2012-01-17T11:03:00+00:00</updated>
    <id>http://artsy.github.io/blog/2012/01/17/responsive-layouts-with-css3</id>
    <content type="html"><![CDATA[<p>All of the <a href="http://sass-lang.com/">SCSS</a> stylesheets used to design this blog compile down to one file (view the source of this page and check out screen.css), and there isn't any JavaScript affecting the layout. But there are really three versions of this page. If you're reading this on a smartphone, what you see is almost entirely different from what you would see if you were reading this in a full screen browser. If you're on a computer, try making this page full screen and slowly resize it to make it smaller. You'll first notice that the Artsy logo disappears just before it would cover the text in the main column. Keep reducing the viewport and eventually the page will snap into a mobile format with the Artsy logo centered at the top, followed by the centered header text and mobile search box all above the index of recent posts.</p>

<a name="The.Philosophy"></a>
<h2>The Philosophy</h2>

<p>Why bother? It's true that smartphone web browsers are pretty advanced and certainly can handle rendering the full version of this blog. But there's a big difference between ensuring a site works and creating a good experience for your audience regardless of the device they're using. If anything, advances in the mobile web make responsive layouts like the one on this blog even more necessary — as it becomes more and more likely that your users are viewing your site on a handheld screen, it becomes less acceptable to force your audience to zoom way into your page and follow the text with their thumbs.</p>

<p>The key to a good mobile design is to fix at least one axis — it's fine if the user has to scroll down or to the right to see the rest of the content, but making the user scroll diagonally means that the layout doesn't fit the screen. For text-heavy sites like this blog, it's best to just allow vertical scrolling. Aside from this consideration, links, text fields, and buttons must be large enough to allow for easy navigation with thumbs. The font size may need to be adjusted to optimize viewing on a mobile screen. On a Mac, you can use mobile Safari on the iPhone Simulator that comes with <a href="http://developer.apple.com/xcode/">Xcode</a> to see how your site will look on a phone.</p>

<a name="Media.Queries"></a>
<h2>Media Queries</h2>

<p>The good news is that these responsive layouts aren't difficult to implement. When I set out to theme this <a href="http://octopress.org/">Octopress</a> blog, our designer gave me two comps, one for the full version of the site and the other for the mobile version. The first step towards a responsive layout is to notice common elements between the two designs. If you compare the two versions of the blog, you'll notice that they contain essentially the same content. This means that we need only one template file for both designs, and definitely do not need to resort to creating a whole mobile subdomain to serve different content to small screens. For elements that aren't the same in the two designs, we can simply hide them by setting <code>display: none</code> for devices where the elements shouldn't be shown. I used this technique in a couple of places on the blog: the right sidebar is hidden on the mobile version, while the mobile search bar (which differs from the search bar on the side in that it has placeholder text and appears in the main content <code>div</code>) isn't displayed on the full version of the site.</p>

<p>But how do you apply different styles to the same elements depending on the size of the browser's viewport? There are a couple of ways, but by far the cleanest way is to use CSS3 media queries. Media queries allow developers to apply different styles to elements on a page depending on the media on which they are displayed, whether that medium is a screen, a projection, print, braille, etc. The most common use of media queries, however, is to create responsive layouts. Media queries come after an <code>@media</code> declaration. Directly after comes the definition of the media type: we're concerned with creating responsive layouts for screens, and as a result, we'll declare our styles under <code>@media screen</code>. To apply custom styles based on the size of the screen, we'll use media features, which come after the keyword <code>and</code> and are enclosed in parentheses. Here's the SCSS code used to style the Artsy logo on this blog:</p>

<pre><code class="scss">    #lrg-mark {
        background-image: url("../images/Logo.png");
        background-repeat: no-repeat;
        display: block;
        height: 92px;
        width: 249px;

        span {
          display: none;
        }

        @media screen and (min-width: 482px) {
          left: 35px;
          position: fixed;
          top: 15px;
        }
        @media screen and (max-width: 1280px) and (min-width: 482px) {
          display: none;
        }
        @media screen and (max-width: 481px) {
          margin: 0 auto 20px auto;
          background-position: center top;
        }
    }
</code></pre>

<p>The styles that are common to all viewports are written outside of <code>@media</code> declarations at the top of the styles for <code>#lrg-mark</code> — regardless of the screen size, we want the logo to be the same image and the same size, and we don't want to display the span inside of the div that contains fallback text. The rest of the styles are given in media queries: for a large viewport, we want the logo fixed in the upper right corner, for slightly smaller viewports, we want it to disappear, and for mobile viewports, we want it centered on the screen. Note that 481px is a magic number: it's the width of an iPhone in landscape mode.</p>

<p>The media features <code>max-width</code> and <code>min-width</code> are a little misleading: they don't mean the maximum or minimum possible width of the user's screen. It's best to think of <code>max-</code> as "less-than-or-equal-to" and <code>min-</code> as "greater-than-or-equal-to." See <a href="http://www.w3.org/TR/css3-mediaqueries/">the W3C's website</a> for a complete reference on CSS media queries.</p>

<a name="Making.It.Cross-Browser"></a>
<h2>Making It Cross-Browser</h2>

<p>CSS3 media queries are awesome, but even though all the latest versions of the major browsers support them, it's very likely that a portion of your site's visitors will be using browsers that don't support these new CSS features. Luckily, this problem has already been solved by great people who like to give away things for free. Just include <a href="https://github.com/Modernizr/Modernizr">modernizr.js</a> on your page, and it will provide a JavaScript fallback for media queries, as well as for many other potentially unsupported CSS3 features.</p>
]]></content>
  </entry>
  
</feed>
